---
title: "Beyond consistency: Contextual dependency of language style in monologue and
  conversation"
output:
  html_document:
    keep_md: yes
    number_sections: yes

---

This R markdown provides the data preparation for our forthcoming manuscript.

To run this from scratch, you will need the following files:

* [This is where a description of the data setup goes]
* `./scripts/bc-libraries_and_functions.r`: Loads in necessary libraries and
creates new functions for our analyses.

**Code written by**: L. C. Mueller-Frommeyer (Technische Universitaet 
Braunschweig) & A. Paxton (University of Connecticut)

**Date last modified**: 12 June 2019

```{r silent-setup, include=FALSE}

# cache our results
library(knitr)
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, cache.lazy=FALSE)

```

***

# Preliminaries

```{r prelim, warning = FALSE, error = FALSE, message = FALSE}

# clear everything
rm(list=ls())

# load libraries and add new functions
source('./scripts/bc-libraries_and_functions.r')

```

***

# Data preparation and analyses for Hypothesis 1 - RQA

##Monologues - Data preparation

```{r load-data}

# get list of monologue files
mon_files = list.files('./data/LIWC-results/RQA/Monologues', pattern = ".txt", full.names = TRUE)
mon_dfs = plyr::ldply(mon_files, read.table, sep="\t", dec = ",", header=TRUE) #added decimal to get numbers instead of characters

```

```{r}

# prepare monologues for RQA
mon_dfs = mon_dfs %>% 
  
  # separate 'Filename' column into separate columns
  tidyr::separate(Filename, 
                  into = c("dyad_id", "dyad_position",  "speaker_code"), 
                  sep = '_', 
                  remove = FALSE, 
                  extra = "drop", 
                  fill = "warn") %>%
  
  # extract speaker number ID and conversation type from variable
  mutate(cond = gsub("[[:digit:]]+","",dyad_id)) %>%
  
  # create new variable function_contrast with all 0 replaced by -1
  dplyr::rename(function_words = function.) %>%
  mutate(function_contrast = dplyr::if_else(function_words==0,
                                            -1,
                                            function_words)) %>%
  
  #add new variable specifying conversation type
  mutate(conv.type = "M")

```

```{r monologues-rqa}

# split dataframe by monologue
split_mon = split(mon_dfs, list(mon_dfs$Filename))

# cycle through the individual monologues
crqa_results_mon = data.frame()
for (next_mon in split_mon){
  
  # run (auto-)recurrence
  rqa_for_mon = crqa(ts1=next_mon$function_words,
                     ts2=next_mon$function_contrast,
                     delay=1,
                     embed=1,
                     r=0.1,
                     normalize=0, 
                     rescale=0, 
                     mindiagline=2,
                     minvertline=2, 
                     tw=1, # exclude line of identity
                     whiteline=FALSE,
                     recpt=FALSE)
  
  # save plot-level information to dataframe
  dyad_id = unique(next_mon$dyad_id)
  speaker_code = unique(next_mon$speaker_code)
  cond = unique(next_mon$cond)
  conv.type = unique(next_mon$conv.type)
  next_data_line = data.frame(dyad_id,  
                              speaker_code,
                              conv.type,
                              rqa_for_mon[1:9])
  crqa_results_mon = rbind.data.frame(crqa_results_mon,next_data_line)
  
}
 colnames(crqa_results_mon) <- paste(colnames(crqa_results_mon), "M", sep = "_")

```

***

##Conversations - Data preparation

```{r load-data}

# get list of conversation files
conv_files = list.files('./data/LIWC-results/RQA/Conversations-1', pattern = ".txt", full.names = TRUE)
conv_dfs = plyr::ldply(conv_files, read.table, sep="\t", dec = ",", header=TRUE) 

```

```{r}

# prepare conversations for RQA
conv_dfs = conv_dfs %>% 
  
  # separate 'Filename' column into separate columns
  tidyr::separate(Filename, 
                  into = c("dyad_id", "dyad_position",  "speaker_code"), 
                  sep = '_', 
                  remove = FALSE, 
                  extra = "drop", 
                  fill = "warn") %>%
  
  # extract speaker number ID and conversation type from variable
  mutate(cond = gsub("[[:digit:]]+","",dyad_id)) %>%
  
  # create new variable function_contrast with all 0 replaced by -1
  dplyr::rename(function_words = function.) %>%
  mutate(function_contrast = dplyr::if_else(function_words==0,
                                            -1,
                                            function_words)) %>%
  
  # add new variable specifying conversation type
  mutate(conv.type = "C")

```

```{r conversations-crqa}

# split dataframe by conversation
split_conv = split(conv_dfs, list(conv_dfs$Filename))

# cycle through the individual monologues
crqa_results_conv = data.frame()
for (next_conv in split_conv){
  
  # run (auto-)recurrence
  rqa_for_conv = crqa(ts1=next_conv$function_words,
                     ts2=next_conv$function_contrast,
                     delay=1,
                     embed=1,
                     r=0.1,
                     normalize=0, 
                     rescale=0, 
                     mindiagline=2,
                     minvertline=2, 
                     tw=1, # exclude line of identity
                     whiteline=FALSE,
                     recpt=FALSE)
  
  # save plot-level information to dataframe
  dyad_id = unique(next_conv$dyad_id)
  speaker_code = unique(next_conv$speaker_code)
  conv.type = unique(next_conv$conv.type)
  cond = unique(next_conv$cond)
  next_data_line = data.frame(dyad_id,  
                              speaker_code,
                              conv.type,
                              cond,
                              rqa_for_conv[1:9])
  crqa_results_conv = rbind.data.frame(crqa_results_conv,next_data_line)
}

# add column names
colnames(crqa_results_conv) <- paste(colnames(crqa_results_conv), "C", sep = "_")

```

```{r}

h1_data = cbind(crqa_results_mon, crqa_results_conv)
#write.table(h1_data, file = 'C:/Users/Lena/Desktop',sep=",") 

```

***
## Analyses for H1
```{r}

```

*** 
#Data preparation and analyses for H2

```{r}
#I added subfolders for speaker A and B for data preparation

# get list of Conversation files speaker A
A_files = list.files('./data/LIWC-results/cRQA/SpeakerA', pattern = ".txt", full.names = TRUE)
A_dfs = plyr::ldply(A_files, read.table, sep="\t", dec = ",", header=TRUE) #added decimal to get numbers instead of characters

```

```{r}

# prepare conversations Speaker A for RQA
A_dfs = A_dfs %>% 
  
  # separate 'Filename' column into separate columns
  tidyr::separate(Filename, 
                  into = c("dyad_id", "dyad_position",  "speaker_code"), 
                  sep = '_', 
                  remove = FALSE, 
                  extra = "drop", 
                  fill = "warn") %>%
  
  # extract speaker number ID and conversation type from variable
  mutate(cond = gsub("[[:digit:]]+","",dyad_id)) %>%
  
  # rename function. to function_words
  dplyr::rename(function_words = function.)
  

#recode fw into quantile
A_dfs$fw_quantiles <- quantcut(A_dfs$function_words, q=4, na.rm = TRUE)

#recode fw into quantiles
A_dfs$fw_quantiles <- quantcut(A_dfs$function_words, q=4, na.rm = TRUE)
A_dfs$fw_quantiles <- ifelse(A_dfs$fw_quantiles == "[0,28.8]", 1, ifelse(A_dfs$fw_quantiles == "(28.8,53.6]", 2, ifelse(A_dfs$fw_quantiles == "(53.6,65.2]", 3, ifelse(A_dfs$fw_quantiles == "(65.2,100]", 4, 99))))


# split dataframe by participant and conversation
split_mon = split(mon_dfs, list(mon_dfs$Filename))

```


# List of next steps

* previous examples
  * look over example of using categorical CRQA from emotion dynamics paper: 
https://github.com/a-paxton/emotion-dynamics/blob/master/get_rqa_measures.R
  * another useful example will be continuous CRQA in dual conversation constraints paper: https://github.com/a-paxton/dual-conversation-constraints/blob/a167f004c71d9637ec30082de13a1ba6283846bb/dual-conversation-constraints.Rmd#L309 (direct link to line)
#for RQA and CRQA, update so that we have all of the variables we need in the
  eventual dataframes (compare with the `mon_dfs` and figure out which to 
  preserve)
#fix CRQA based on fixes to RQA today
#add variable to monologue and dialogue dataframes to specify monologue v.
  dialogue
* add a step to save the eventual table

* start doing categorical CRQA
  * create quartiles of function words -- function `quantile`
  * recode 0 appearances of function words as something else (e.g., 0 for one participant, -1 for the other)
  * run categorical CRQA with `tw=0` over all of these
  * create baseline surrogate measures for H2